-- ╔═══════════════════════════════════════════════════════════════╗
-- ║   COMPLETE GYM APPLICATION + PAYMENT DASHBOARD DATABASE     ║
-- ║   Run this ONCE in Supabase SQL Editor (safe to re-run)     ║
-- ╚═══════════════════════════════════════════════════════════════╝
--
-- This single file contains EVERYTHING:
--   1. Super admin allow-list table
--   2. Admin accounts table + approval flow
--   3. All gym data tables (with owner_id for multi-tenancy)
--   4. Row Level Security policies (owner-scoped)
--   5. Helper functions & triggers
--   6. Auto-signup trigger on auth.users
--   7. Real-time setup
--
-- Each admin only sees their own gym's data.
-- Super admins (in super_admins table) can see all data.
-- ═══════════════════════════════════════════════════════════════


-- ═══════════════════════════════════════════════════════════════
-- SECTION 1: SUPER ADMINS TABLE
-- ═══════════════════════════════════════════════════════════════

CREATE TABLE IF NOT EXISTS public.super_admins (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  email TEXT NOT NULL UNIQUE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

ALTER TABLE public.super_admins ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "super_admins_authenticated_read" ON public.super_admins;
CREATE POLICY "super_admins_authenticated_read"
  ON public.super_admins FOR SELECT TO authenticated
  USING (true);

-- *** CHANGE THIS to your actual super admin email ***
INSERT INTO public.super_admins (email)
VALUES ('owner@gympro.com')
ON CONFLICT (email) DO NOTHING;


-- ═══════════════════════════════════════════════════════════════
-- SECTION 2: HELPER FUNCTION — is_super_admin()
-- ═══════════════════════════════════════════════════════════════

CREATE OR REPLACE FUNCTION public.is_super_admin()
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  jwt_email TEXT;
BEGIN
  jwt_email := lower(coalesce(auth.jwt() ->> 'email', ''));
  IF jwt_email = '' THEN RETURN false; END IF;
  RETURN EXISTS (
    SELECT 1 FROM public.super_admins sa WHERE lower(sa.email) = jwt_email
  );
END;
$$;


-- ═══════════════════════════════════════════════════════════════
-- SECTION 3: ADMIN ACCOUNTS TABLE (signup + payment approval)
-- ═══════════════════════════════════════════════════════════════

CREATE TABLE IF NOT EXISTS public.admin_accounts (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID UNIQUE REFERENCES auth.users(id) ON DELETE CASCADE,
  full_name TEXT NOT NULL,
  gym_name TEXT NOT NULL,
  email TEXT NOT NULL,
  plan_type TEXT NOT NULL CHECK (plan_type IN ('monthly', 'six_months', 'yearly')),
  plan_price NUMERIC(12,2) NOT NULL,
  payment_status TEXT NOT NULL DEFAULT 'pending'
    CHECK (payment_status IN ('pending', 'approved', 'rejected')),
  approval_status TEXT NOT NULL DEFAULT 'pending'
    CHECK (approval_status IN ('pending', 'approved', 'rejected')),
  is_active BOOLEAN NOT NULL DEFAULT false,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_admin_accounts_created_at ON public.admin_accounts(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_admin_accounts_email ON public.admin_accounts(email);

ALTER TABLE public.admin_accounts ENABLE ROW LEVEL SECURITY;

-- Owner can read their own row
DROP POLICY IF EXISTS "admin_accounts_owner_read" ON public.admin_accounts;
CREATE POLICY "admin_accounts_owner_read"
  ON public.admin_accounts FOR SELECT TO authenticated
  USING (auth.uid() = user_id);

-- Owner can insert their own row
DROP POLICY IF EXISTS "admin_accounts_owner_insert" ON public.admin_accounts;
CREATE POLICY "admin_accounts_owner_insert"
  ON public.admin_accounts FOR INSERT TO authenticated
  WITH CHECK (auth.uid() = user_id);

-- Owner can update their own row
DROP POLICY IF EXISTS "admin_accounts_owner_update" ON public.admin_accounts;
CREATE POLICY "admin_accounts_owner_update"
  ON public.admin_accounts FOR UPDATE TO authenticated
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

-- Super admin can read ALL admin accounts
DROP POLICY IF EXISTS "admin_accounts_super_admin_read" ON public.admin_accounts;
CREATE POLICY "admin_accounts_super_admin_read"
  ON public.admin_accounts FOR SELECT TO authenticated
  USING (public.is_super_admin());

-- Super admin can update ALL admin accounts (approve/reject)
DROP POLICY IF EXISTS "admin_accounts_super_admin_update" ON public.admin_accounts;
CREATE POLICY "admin_accounts_super_admin_update"
  ON public.admin_accounts FOR UPDATE TO authenticated
  USING (public.is_super_admin())
  WITH CHECK (public.is_super_admin());


-- ═══════════════════════════════════════════════════════════════
-- SECTION 4: GYM DATA TABLES (all have owner_id)
-- ═══════════════════════════════════════════════════════════════

-- 4a. MEMBERS
CREATE TABLE IF NOT EXISTS public.members (
  id BIGSERIAL PRIMARY KEY,
  owner_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  contact TEXT,
  fee NUMERIC DEFAULT 0,
  payment TEXT DEFAULT 'Paid',
  status TEXT DEFAULT 'Active',
  profile TEXT,
  scoops_creatine NUMERIC DEFAULT 0,
  scoops_whey NUMERIC DEFAULT 0,
  scoops_preworkout NUMERIC DEFAULT 0,
  cost_creatine NUMERIC DEFAULT 0,
  cost_whey NUMERIC DEFAULT 0,
  cost_preworkout NUMERIC DEFAULT 0,
  join_date TIMESTAMPTZ DEFAULT now(),
  created_at TIMESTAMPTZ DEFAULT now()
);

-- Add owner_id if table already exists without it
ALTER TABLE public.members
  ADD COLUMN IF NOT EXISTS owner_id UUID REFERENCES auth.users(id) ON DELETE CASCADE;

CREATE INDEX IF NOT EXISTS idx_members_owner ON public.members(owner_id);


-- 4b. ATTENDANCE
CREATE TABLE IF NOT EXISTS public.attendance (
  id BIGSERIAL PRIMARY KEY,
  owner_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  member_id BIGINT REFERENCES public.members(id) ON DELETE CASCADE,
  date DATE NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now(),
  UNIQUE(member_id, date)
);

ALTER TABLE public.attendance
  ADD COLUMN IF NOT EXISTS owner_id UUID REFERENCES auth.users(id) ON DELETE CASCADE;

CREATE INDEX IF NOT EXISTS idx_attendance_owner ON public.attendance(owner_id);


-- 4c. PAYMENTS
CREATE TABLE IF NOT EXISTS public.payments (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  owner_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  member_id BIGINT REFERENCES public.members(id) ON DELETE CASCADE NOT NULL,
  amount NUMERIC DEFAULT 0,
  month_year TEXT NOT NULL,
  status TEXT DEFAULT 'Paid',
  created_at TIMESTAMPTZ DEFAULT now(),
  UNIQUE(member_id, month_year)
);

ALTER TABLE public.payments
  ADD COLUMN IF NOT EXISTS owner_id UUID REFERENCES auth.users(id) ON DELETE CASCADE;

CREATE INDEX IF NOT EXISTS idx_payments_owner ON public.payments(owner_id);
CREATE INDEX IF NOT EXISTS idx_payments_member_month ON public.payments(member_id, month_year);


-- 4d. CLASSES
CREATE TABLE IF NOT EXISTS public.classes (
  id BIGSERIAL PRIMARY KEY,
  owner_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  instructor TEXT,
  time TEXT,
  days JSONB,
  capacity INTEGER DEFAULT 20,
  created_at TIMESTAMPTZ DEFAULT now()
);

ALTER TABLE public.classes
  ADD COLUMN IF NOT EXISTS owner_id UUID REFERENCES auth.users(id) ON DELETE CASCADE;

CREATE INDEX IF NOT EXISTS idx_classes_owner ON public.classes(owner_id);


-- 4e. GYM SETTINGS
CREATE TABLE IF NOT EXISTS public.gym_settings (
  id BIGSERIAL PRIMARY KEY,
  owner_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  category TEXT NOT NULL,
  settings JSONB NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT now()
);

ALTER TABLE public.gym_settings
  ADD COLUMN IF NOT EXISTS owner_id UUID REFERENCES auth.users(id) ON DELETE CASCADE;

-- Fix unique constraint: each owner gets their own settings per category
ALTER TABLE public.gym_settings DROP CONSTRAINT IF EXISTS gym_settings_category_key;
ALTER TABLE public.gym_settings DROP CONSTRAINT IF EXISTS gym_settings_owner_category_key;
ALTER TABLE public.gym_settings
  ADD CONSTRAINT gym_settings_owner_category_key UNIQUE (owner_id, category);

CREATE INDEX IF NOT EXISTS idx_gym_settings_owner ON public.gym_settings(owner_id);


-- 4f. CARDIO SUBSCRIPTIONS
CREATE TABLE IF NOT EXISTS public.cardio_subscriptions (
  id BIGSERIAL PRIMARY KEY,
  owner_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  member_id BIGINT REFERENCES public.members(id) ON DELETE CASCADE,
  duration TEXT NOT NULL,
  type TEXT NOT NULL,
  price NUMERIC NOT NULL,
  start_date DATE DEFAULT CURRENT_DATE,
  end_date DATE,
  status TEXT DEFAULT 'Active',
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);

ALTER TABLE public.cardio_subscriptions
  ADD COLUMN IF NOT EXISTS owner_id UUID REFERENCES auth.users(id) ON DELETE CASCADE;

CREATE INDEX IF NOT EXISTS idx_cardio_subscriptions_owner ON public.cardio_subscriptions(owner_id);


-- 4g. TRAINING PLANS
CREATE TABLE IF NOT EXISTS public.training_plans (
  id BIGSERIAL PRIMARY KEY,
  owner_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  member_id BIGINT REFERENCES public.members(id) ON DELETE CASCADE,
  plan_name TEXT DEFAULT 'Personal Training',
  plan_type TEXT,
  trainer_name TEXT,
  price NUMERIC DEFAULT 0,
  start_date DATE DEFAULT CURRENT_DATE,
  end_date DATE,
  status TEXT DEFAULT 'Active',
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);

ALTER TABLE public.training_plans
  ADD COLUMN IF NOT EXISTS owner_id UUID REFERENCES auth.users(id) ON DELETE CASCADE;

CREATE INDEX IF NOT EXISTS idx_training_plans_owner ON public.training_plans(owner_id);


-- ═══════════════════════════════════════════════════════════════
-- SECTION 5: ENABLE ROW LEVEL SECURITY ON ALL TABLES
-- ═══════════════════════════════════════════════════════════════

ALTER TABLE public.members ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.attendance ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.payments ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.classes ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.gym_settings ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.cardio_subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.training_plans ENABLE ROW LEVEL SECURITY;


-- ═══════════════════════════════════════════════════════════════
-- SECTION 6: NUCLEAR CLEANUP — DROP ALL OLD PERMISSIVE POLICIES
--   PostgreSQL OR's policies together, so ANY old "USING (true)"
--   policy would leak data across gyms. We drop everything first.
-- ═══════════════════════════════════════════════════════════════

DO $$
DECLARE
  _tbl TEXT;
  _pol RECORD;
BEGIN
  FOREACH _tbl IN ARRAY ARRAY[
    'members','attendance','payments','classes',
    'gym_settings','cardio_subscriptions','training_plans'
  ]
  LOOP
    FOR _pol IN
      SELECT policyname
      FROM pg_policies
      WHERE schemaname = 'public' AND tablename = _tbl
    LOOP
      EXECUTE format('DROP POLICY IF EXISTS %I ON public.%I', _pol.policyname, _tbl);
      RAISE NOTICE 'Dropped policy: % on %', _pol.policyname, _tbl;
    END LOOP;
  END LOOP;
END $$;


-- ═══════════════════════════════════════════════════════════════
-- SECTION 7: CREATE OWNER-SCOPED RLS POLICIES
--   Admin sees own gym data only. Super admin sees everything.
-- ═══════════════════════════════════════════════════════════════

CREATE POLICY "members_owner_all" ON public.members
  FOR ALL TO authenticated
  USING (owner_id = auth.uid() OR public.is_super_admin())
  WITH CHECK (owner_id = auth.uid() OR public.is_super_admin());

CREATE POLICY "attendance_owner_all" ON public.attendance
  FOR ALL TO authenticated
  USING (owner_id = auth.uid() OR public.is_super_admin())
  WITH CHECK (owner_id = auth.uid() OR public.is_super_admin());

CREATE POLICY "payments_owner_all" ON public.payments
  FOR ALL TO authenticated
  USING (owner_id = auth.uid() OR public.is_super_admin())
  WITH CHECK (owner_id = auth.uid() OR public.is_super_admin());

CREATE POLICY "classes_owner_all" ON public.classes
  FOR ALL TO authenticated
  USING (owner_id = auth.uid() OR public.is_super_admin())
  WITH CHECK (owner_id = auth.uid() OR public.is_super_admin());

CREATE POLICY "gym_settings_owner_all" ON public.gym_settings
  FOR ALL TO authenticated
  USING (owner_id = auth.uid() OR public.is_super_admin())
  WITH CHECK (owner_id = auth.uid() OR public.is_super_admin());

CREATE POLICY "cardio_subscriptions_owner_all" ON public.cardio_subscriptions
  FOR ALL TO authenticated
  USING (owner_id = auth.uid() OR public.is_super_admin())
  WITH CHECK (owner_id = auth.uid() OR public.is_super_admin());

CREATE POLICY "training_plans_owner_all" ON public.training_plans
  FOR ALL TO authenticated
  USING (owner_id = auth.uid() OR public.is_super_admin())
  WITH CHECK (owner_id = auth.uid() OR public.is_super_admin());


-- ═══════════════════════════════════════════════════════════════
-- SECTION 8: HELPER FUNCTIONS & TRIGGERS
-- ═══════════════════════════════════════════════════════════════

-- Generic updated_at trigger function
CREATE OR REPLACE FUNCTION public.update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- admin_accounts updated_at
CREATE OR REPLACE FUNCTION public.set_updated_at_admin_accounts()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_admin_accounts_updated_at ON public.admin_accounts;
CREATE TRIGGER trg_admin_accounts_updated_at
  BEFORE UPDATE ON public.admin_accounts
  FOR EACH ROW EXECUTE FUNCTION public.set_updated_at_admin_accounts();

-- ── auto_set_owner_id — safety net for INSERT ──────────────
-- If the client doesn't send owner_id, fill it from auth.uid()
CREATE OR REPLACE FUNCTION public.auto_set_owner_id()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  IF NEW.owner_id IS NULL THEN
    NEW.owner_id := auth.uid();
  END IF;
  RETURN NEW;
END;
$$;

-- Apply auto_owner_id to every data table
DO $$
DECLARE
  _tbl TEXT;
BEGIN
  FOREACH _tbl IN ARRAY ARRAY[
    'members','attendance','payments','classes',
    'gym_settings','cardio_subscriptions','training_plans'
  ]
  LOOP
    EXECUTE format(
      'DROP TRIGGER IF EXISTS auto_owner_id ON public.%I', _tbl
    );
    EXECUTE format(
      'CREATE TRIGGER auto_owner_id
         BEFORE INSERT ON public.%I
         FOR EACH ROW EXECUTE FUNCTION public.auto_set_owner_id()', _tbl
    );
  END LOOP;
END $$;

-- gym_settings updated_at
DROP TRIGGER IF EXISTS update_gym_settings_updated_at ON public.gym_settings;
CREATE TRIGGER update_gym_settings_updated_at
  BEFORE UPDATE ON public.gym_settings
  FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

-- cardio_subscriptions updated_at
DROP TRIGGER IF EXISTS update_cardio_subscriptions_updated_at ON public.cardio_subscriptions;
CREATE TRIGGER update_cardio_subscriptions_updated_at
  BEFORE UPDATE ON public.cardio_subscriptions
  FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

-- training_plans updated_at
DROP TRIGGER IF EXISTS update_training_plans_updated_at ON public.training_plans;
CREATE TRIGGER update_training_plans_updated_at
  BEFORE UPDATE ON public.training_plans
  FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


-- ═══════════════════════════════════════════════════════════════
-- SECTION 9: AUTO-CREATE ADMIN ACCOUNT ON SIGNUP
--   Fires when a new user signs up via Supabase Auth.
--   Reads user_metadata and creates a pending admin_accounts row.
-- ═══════════════════════════════════════════════════════════════

CREATE OR REPLACE FUNCTION public.handle_new_admin_signup()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  IF NEW.raw_user_meta_data ->> 'role' = 'admin_owner' THEN
    INSERT INTO public.admin_accounts (
      user_id, full_name, gym_name, email,
      plan_type, plan_price,
      payment_status, approval_status, is_active
    ) VALUES (
      NEW.id,
      COALESCE(NEW.raw_user_meta_data ->> 'full_name', NEW.email),
      COALESCE(NEW.raw_user_meta_data ->> 'gym_name', 'New Gym'),
      NEW.email,
      COALESCE(NEW.raw_user_meta_data ->> 'plan_type', 'monthly'),
      COALESCE((NEW.raw_user_meta_data ->> 'plan_price')::numeric, 5000),
      'pending',
      'pending',
      false
    ) ON CONFLICT (user_id) DO NOTHING;
  END IF;
  RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_admin_signup();


-- ═══════════════════════════════════════════════════════════════
-- SECTION 10: ENABLE REAL-TIME
-- ═══════════════════════════════════════════════════════════════

DO $$
BEGIN
  -- Safely add to realtime publication (ignore if already added)
  BEGIN
    ALTER PUBLICATION supabase_realtime ADD TABLE public.admin_accounts;
  EXCEPTION WHEN duplicate_object THEN
    RAISE NOTICE 'admin_accounts already in supabase_realtime';
  END;
END $$;


-- ═══════════════════════════════════════════════════════════════
-- SECTION 11: (OPTIONAL) BACKFILL EXISTING DATA
-- ═══════════════════════════════════════════════════════════════
-- If you already have data without owner_id, assign them:
--
--   UPDATE public.members SET owner_id = '<uuid>' WHERE owner_id IS NULL;
--   UPDATE public.attendance SET owner_id = '<uuid>' WHERE owner_id IS NULL;
--   UPDATE public.payments SET owner_id = '<uuid>' WHERE owner_id IS NULL;
--   UPDATE public.classes SET owner_id = '<uuid>' WHERE owner_id IS NULL;
--   UPDATE public.gym_settings SET owner_id = '<uuid>' WHERE owner_id IS NULL;
--   UPDATE public.cardio_subscriptions SET owner_id = '<uuid>' WHERE owner_id IS NULL;
--   UPDATE public.training_plans SET owner_id = '<uuid>' WHERE owner_id IS NULL;
--
-- Get the UUID from: SELECT user_id FROM admin_accounts WHERE email = 'your@email.com';


-- ═══════════════════════════════════════════════════════════════
-- DONE!
-- ═══════════════════════════════════════════════════════════════
-- Tables created:
--   • super_admins          — email allow-list for super admins
--   • admin_accounts        — gym admin signup requests + approval
--   • members               — gym members (scoped by owner_id)
--   • attendance            — daily attendance (scoped by owner_id)
--   • payments              — monthly payment records (scoped by owner_id)
--   • classes               — gym class schedule (scoped by owner_id)
--   • gym_settings          — settings per gym (scoped by owner_id)
--   • cardio_subscriptions  — cardio plans (scoped by owner_id)
--   • training_plans        — PT plans (scoped by owner_id)
--
-- RLS:
--   • Each admin sees only rows with their own owner_id
--   • Super admins see all rows across all gyms
--   • admin_accounts: owners see own row, super admins see all
--
-- Triggers:
--   • on_auth_user_created → auto-creates admin_accounts row on signup
--   • updated_at auto-set on admin_accounts, gym_settings,
--     cardio_subscriptions, training_plans
-- ═══════════════════════════════════════════════════════════════
