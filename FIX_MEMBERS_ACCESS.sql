-- ═══════════════════════════════════════════════════════════════
-- FIX: MEMBERS ACCESS REPAIR
-- Run this in the Supabase SQL Editor to fix
-- "Cannot add member / cannot see any member"
-- ═══════════════════════════════════════════════════════════════


-- ────────────────────────────────────────────────────────────
-- STEP 1: Ensure is_super_admin() function exists
-- ────────────────────────────────────────────────────────────

CREATE TABLE IF NOT EXISTS public.super_admins (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  email TEXT UNIQUE NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE OR REPLACE FUNCTION public.is_super_admin()
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM public.super_admins
    WHERE email = (
      SELECT email FROM auth.users WHERE id = auth.uid()
    )
  );
END;
$$;


-- ────────────────────────────────────────────────────────────
-- STEP 2: Ensure owner_id column exists on all data tables
-- ────────────────────────────────────────────────────────────

ALTER TABLE public.members
  ADD COLUMN IF NOT EXISTS owner_id UUID REFERENCES auth.users(id) ON DELETE CASCADE;
ALTER TABLE public.attendance
  ADD COLUMN IF NOT EXISTS owner_id UUID REFERENCES auth.users(id) ON DELETE CASCADE;
ALTER TABLE public.payments
  ADD COLUMN IF NOT EXISTS owner_id UUID REFERENCES auth.users(id) ON DELETE CASCADE;
ALTER TABLE public.classes
  ADD COLUMN IF NOT EXISTS owner_id UUID REFERENCES auth.users(id) ON DELETE CASCADE;
ALTER TABLE public.gym_settings
  ADD COLUMN IF NOT EXISTS owner_id UUID REFERENCES auth.users(id) ON DELETE CASCADE;
ALTER TABLE public.cardio_subscriptions
  ADD COLUMN IF NOT EXISTS owner_id UUID REFERENCES auth.users(id) ON DELETE CASCADE;
ALTER TABLE public.training_plans
  ADD COLUMN IF NOT EXISTS owner_id UUID REFERENCES auth.users(id) ON DELETE CASCADE;


-- ────────────────────────────────────────────────────────────
-- STEP 3: Enable RLS on all data tables
-- ────────────────────────────────────────────────────────────

ALTER TABLE public.members ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.attendance ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.payments ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.classes ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.gym_settings ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.cardio_subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.training_plans ENABLE ROW LEVEL SECURITY;


-- ────────────────────────────────────────────────────────────
-- STEP 4: Nuclear cleanup — drop ALL existing policies
--   This ensures no stale or conflicting policies remain
-- ────────────────────────────────────────────────────────────

DO $$
DECLARE
  _tbl TEXT;
  _pol RECORD;
BEGIN
  FOREACH _tbl IN ARRAY ARRAY[
    'members','attendance','payments','classes',
    'gym_settings','cardio_subscriptions','training_plans'
  ]
  LOOP
    FOR _pol IN
      SELECT policyname
      FROM pg_policies
      WHERE schemaname = 'public' AND tablename = _tbl
    LOOP
      EXECUTE format('DROP POLICY IF EXISTS %I ON public.%I', _pol.policyname, _tbl);
      RAISE NOTICE 'Dropped: %.%', _tbl, _pol.policyname;
    END LOOP;
  END LOOP;
END $$;


-- ────────────────────────────────────────────────────────────
-- STEP 5: Recreate owner-scoped RLS policies
-- ────────────────────────────────────────────────────────────

CREATE POLICY "members_owner_all" ON public.members
  FOR ALL TO authenticated
  USING (owner_id = auth.uid() OR public.is_super_admin())
  WITH CHECK (owner_id = auth.uid() OR public.is_super_admin());

CREATE POLICY "attendance_owner_all" ON public.attendance
  FOR ALL TO authenticated
  USING (owner_id = auth.uid() OR public.is_super_admin())
  WITH CHECK (owner_id = auth.uid() OR public.is_super_admin());

CREATE POLICY "payments_owner_all" ON public.payments
  FOR ALL TO authenticated
  USING (owner_id = auth.uid() OR public.is_super_admin())
  WITH CHECK (owner_id = auth.uid() OR public.is_super_admin());

CREATE POLICY "classes_owner_all" ON public.classes
  FOR ALL TO authenticated
  USING (owner_id = auth.uid() OR public.is_super_admin())
  WITH CHECK (owner_id = auth.uid() OR public.is_super_admin());

CREATE POLICY "gym_settings_owner_all" ON public.gym_settings
  FOR ALL TO authenticated
  USING (owner_id = auth.uid() OR public.is_super_admin())
  WITH CHECK (owner_id = auth.uid() OR public.is_super_admin());

CREATE POLICY "cardio_subscriptions_owner_all" ON public.cardio_subscriptions
  FOR ALL TO authenticated
  USING (owner_id = auth.uid() OR public.is_super_admin())
  WITH CHECK (owner_id = auth.uid() OR public.is_super_admin());

CREATE POLICY "training_plans_owner_all" ON public.training_plans
  FOR ALL TO authenticated
  USING (owner_id = auth.uid() OR public.is_super_admin())
  WITH CHECK (owner_id = auth.uid() OR public.is_super_admin());


-- ────────────────────────────────────────────────────────────
-- STEP 6: Auto-set owner_id trigger (safety net)
--   If the client forgets to send owner_id, this trigger
--   automatically fills it from auth.uid() on INSERT.
-- ────────────────────────────────────────────────────────────

CREATE OR REPLACE FUNCTION public.auto_set_owner_id()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  IF NEW.owner_id IS NULL THEN
    NEW.owner_id := auth.uid();
  END IF;
  RETURN NEW;
END;
$$;

-- Apply the trigger to every data table
DO $$
DECLARE
  _tbl TEXT;
BEGIN
  FOREACH _tbl IN ARRAY ARRAY[
    'members','attendance','payments','classes',
    'gym_settings','cardio_subscriptions','training_plans'
  ]
  LOOP
    EXECUTE format(
      'DROP TRIGGER IF EXISTS auto_owner_id ON public.%I', _tbl
    );
    EXECUTE format(
      'CREATE TRIGGER auto_owner_id
         BEFORE INSERT ON public.%I
         FOR EACH ROW EXECUTE FUNCTION public.auto_set_owner_id()', _tbl
    );
    RAISE NOTICE 'auto_owner_id trigger created on %', _tbl;
  END LOOP;
END $$;


-- ────────────────────────────────────────────────────────────
-- STEP 7: Backfill existing data that has NULL owner_id
--   Assigns orphan rows to the first admin user it finds.
--   If you have multiple admins, update these manually per gym.
-- ────────────────────────────────────────────────────────────

DO $$
DECLARE
  _owner UUID;
BEGIN
  -- Pick the first approved admin, or any admin if none approved yet
  SELECT user_id INTO _owner
  FROM public.admin_accounts
  ORDER BY
    CASE WHEN approval_status = 'approved' THEN 0 ELSE 1 END,
    created_at ASC
  LIMIT 1;

  IF _owner IS NULL THEN
    RAISE NOTICE 'No admin_accounts found — skipping backfill. Data with NULL owner_id will remain invisible until owner_id is set.';
    RETURN;
  END IF;

  RAISE NOTICE 'Backfilling NULL owner_id rows to admin: %', _owner;

  UPDATE public.members SET owner_id = _owner WHERE owner_id IS NULL;
  UPDATE public.attendance SET owner_id = _owner WHERE owner_id IS NULL;
  UPDATE public.payments SET owner_id = _owner WHERE owner_id IS NULL;
  UPDATE public.classes SET owner_id = _owner WHERE owner_id IS NULL;
  UPDATE public.gym_settings SET owner_id = _owner WHERE owner_id IS NULL;
  UPDATE public.cardio_subscriptions SET owner_id = _owner WHERE owner_id IS NULL;
  UPDATE public.training_plans SET owner_id = _owner WHERE owner_id IS NULL;

  RAISE NOTICE 'Backfill complete!';
END $$;


-- ────────────────────────────────────────────────────────────
-- STEP 8: Verify — show policy count per table
-- ────────────────────────────────────────────────────────────

SELECT tablename, COUNT(*) AS policy_count
FROM pg_policies
WHERE schemaname = 'public'
  AND tablename IN (
    'members','attendance','payments','classes',
    'gym_settings','cardio_subscriptions','training_plans'
  )
GROUP BY tablename
ORDER BY tablename;


-- ────────────────────────────────────────────────────────────
-- DONE! Each table should show policy_count = 1
-- ────────────────────────────────────────────────────────────
